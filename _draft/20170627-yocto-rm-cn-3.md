
### Chapter 3. 近观 Yocto 项目开发环境[¶][1829]

This chapter takes a more detailed look at the Yocto Project development environment. The following diagram represents the development environment at a high level. The remainder of this chapter expands on the fundamental input, output, process, and [Metadata][4525]) blocks in the Yocto Project development environment.
本章将会详细的介绍 Yocto 项目开发环境。下面的图表充高层次展示了开发环境。本章剩余的部分会展开 Yocto 项目开发环境的基础输入、输出、处理和[元数据][4525] 块。


![](https://www.yoctoproject.org/docs/current/ref-manual/figures/yocto-environment-ref.png)


The generalized Yocto Project Development Environment consists of several functional areas:
生成好的 Yocto 项目开发环境由下面几个功能块组成：

*   _User Configuration:_  Metadata you can use to control the build process.
*   _User Configuration:_  你可以用来控制构建过程的元数据。

*   _Metadata Layers:_  Various layers that provide software, machine, and distro Metadata.
*   _Metadata Layers:_  多种 layer 用来提供软件、机器和发行版元数据。

*   _Source Files:_  Upstream releases, local projects, and SCMs.
*   _Source Files:_ 上游发布的，本地项目，和 SCM。

*   _Build System:_  Processes under the control of [BitBake][3455]. This block expands on how BitBake fetches source, applies patches, completes compilation, analyzes output for package generation, creates and tests packages, generates images, and generates cross-development tools.
*   _Build System:_  [BitBake][3455] 控制的程序。这一块会展开 BitBake 如何获取代码，应用补丁，完成编译，分析包的生成结果、创建和测试软件包，生成镜像，以及生成交叉编译工具链。

*   _Package Feeds:_  Directories containing output packages (RPM, DEB or IPK), which are subsequently used in the construction of an image or SDK, produced by the build system. These feeds can also be copied and shared using a web server or other means to facilitate extending or updating existing images on devices at runtime if runtime package management is enabled.
*   _Package Feeds:_  包含生成的软件包（RPM、DEB或 IPK）的目录，是构造镜像或 SDK 的子过程，通过构建系统生成。 这些源头可以通过web 服务器拷贝和共享，或者其他途径来提高扩展性或在运行时更新已有的镜像，如果运行时软件包管理是使能的。

*   _Images:_  Images produced by the development process.
*   _Images:_  开发过程产生的镜像。

*   _Application Development SDK:_  Cross-development tools that are produced along with an image or separately with BitBake.
*   _Application Development SDK:_  BitBake 生成的、和镜像一起的或单独的交叉编译工具。

### 3.1. 用户配置[¶][817]

User configuration helps define the build. Through user configuration, you can tell BitBake the target architecture for which you are building the image, where to store downloaded source, and other build properties.
用户配置帮助定义构建过程。通过用户配置，你可以告诉 BitBake 你构建的镜像是什么架构，在哪里保存下载的源码，以及其他属性。

The following figure shows an expanded representation of the "User Configuration" box of the [general Yocto Project Development Environment figure][4176]:
下面的表格展示了一个[通用 Yocto 项目开发环境表格][4176]的展开的表现用户配置的盒子。

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/user-configuration.png)

BitBake needs some basic configuration files in order to complete a build. These files are `*.conf` files. The minimally necessary ones reside as example files in the [Source Directory][4177]. For simplicity, this section refers to the Source Directory as the "Poky Directory."
BitBake 需要一些基本的配置文件来完成构建。这些文件是 `*.conf`。最少需要的文件是位于 [Source Directory][4177] 作为例子的文件。简单来说，这部分 Source Directory 被称为 "Poky Directory" 。

When you clone the `poky` Git repository or you download and unpack a Yocto Project release, you can set up the Source Directory to be named anything you want. For this discussion, the cloned repository uses the default name `poky`.
当你克隆 `poky` git 仓库或者下载、解压缩 Yocto项目发布版之后，你可以设置 Source Directory为任何你想要的名字。为了讨论，接下来克隆的仓库会使用默认名字 `poky`。

### Note

The Poky repository is primarily an aggregation of existing repositories. It is not a canonical upstream source.
Poky 仓库是基本是一些存在的仓库的集合。它不是一个典型上游源。

The `meta-poky` layer inside Poky contains a `conf` directory that has example configuration files. These example files are used as a basis for creating actual configuration files when you source the build environment script (i.e. [`oe-init-build-env`][4178] or [`oe-init-build-env-memres`][4179]).
在 Poky 中的 `meta-poky` layer 包含一个 `conf` 目录有一些配置文件的例子。这些示例文件是当你执行构建环境脚本时创建实际配置文件的基础。（比如 `oe-init-build-env`][4178] 或者 [`oe-init-build-env-memres`][4179]）。

Sourcing the build environment script creates a [Build Directory][4180] if one does not already exist. BitBake uses the Build Directory for all its work during builds. The Build Directory has a `conf` directory that contains default versions of your `local.conf` and `bblayers.conf` configuration files. These default configuration files are created only if versions do not already exist in the Build Directory at the time you source the build environment setup script.
执行构建环境脚本时，如果 [Build Directory][4180] 不存在就会创建一个。BitBake 在整个构建工作过程中都使用 Build Directory。这个 Build Directory 有一个 `conf` 目录保存了你的默认版本的`local.conf` 和`bblayers.conf` 配置文件。如果你在执行构建环境脚本时， Build Directory 没有配置文件，就会创建这些默认的配置文件。

Because the Poky repository is fundamentally an aggregation of existing repositories, some users might be familiar with running the `oe-init-build-env` or `oe-init-build-env-memres` script in the context of separate OpenEmbedded-Core and BitBake repositories rather than a single Poky repository. This discussion assumes the script is executed from within a cloned or unpacked version of Poky.
因为 Poky 仓库根本上师一些现存仓库的聚集，有些用户可能会熟悉在分开的 OpenEmbedded-Core 和BitBake 仓库而不是单独的 Poky 仓库中运行 `oe-init-build-env` 或 `oe-init-build-env-memres` 脚本。下面的讨论假设脚本是在一个克隆的或者解压缩班的 Poky 中执行的。

Depending on where the script is sourced, different sub-scripts are called to set up the Build Directory (Yocto or OpenEmbedded). Specifically, the script `scripts/oe-setup-builddir` inside the poky directory sets up the Build Directory and seeds the directory (if necessary) with configuration files appropriate for the Yocto Project development environment.
根据脚本是在何处执行的，不同的子脚本会被调用来搭建 Build Directory（Yocto 或者 OpenEmbedded）。特别的，在 poky 目录中的脚本 `scripts/oe-setup-builddir` 配合适合 Yocto 项目开发环境的配置文件搭建 Build Directory 和 seed 目录（如果必要）。

### Note

The `scripts/oe-setup-builddir` script uses the `$TEMPLATECONF` variable to determine which sample configuration files to locate.
`scripts/oe-setup-builddir` 脚本使用变量 `$TEMPLATECONF` 来决定要定位那个示例配置文件。

The `local.conf` file provides many basic variables that define a build environment. Here is a list of a few. To see the default configurations in a `local.conf` file created by the build environment script, see the `local.conf.sample` in the `meta-poky` layer:
`local.conf` 文件提供了很多定义构建环境的基础变量。这里的列表是很少的一部分。要查看由构建环境脚本创建的 `local.conf` 文件中的默认配置，可以看 `meta-poky` layer 中的 `local.conf.sample`：

*   _Parallelism Options:_  Controlled by the [`BB_NUMBER_THREADS`][1830], [`PARALLEL_MAKE`][1831], and [`BB_NUMBER_PARSE_THREADS`][1832] variables.
*   _Parallelism Options:_  受变量 [`BB_NUMBER_THREADS`][1830], [`PARALLEL_MAKE`][1831], 和[`BB_NUMBER_PARSE_THREADS`][1832] 控制.

*   _Target Machine Selection:_  Controlled by the [`MACHINE`][1833] variable.
*   _Target Machine Selection:_  由变量 [`MACHINE`][1833] 控制.

*   _Download Directory:_  Controlled by the [`DL_DIR`][1834] variable.
*   _Download Directory:_  由变量 [`DL_DIR`][1834] 控制.

*   _Shared State Directory:_  Controlled by the [`SSTATE_DIR`][1835] variable.
*   _Shared State Directory:_  由变量 [`SSTATE_DIR`][1835] 控制.

*   _Build Output:_  Controlled by the [`TMPDIR`][1836] variable.
*   _Build Output:_  由变量 [`TMPDIR`][1836] 控制.

### Note

Configurations set in the `conf/local.conf` file can also be set in the `conf/site.conf` and `conf/auto.conf` configuration files.
`conf/local.conf` 设置的配置也可以被设置在 `conf/site.conf` 和 `conf/auto.conf` 配置文件。

The `bblayers.conf` file tells BitBake what layers you want considered during the build. By default, the layers listed in this file include layers minimally needed by the build system. However, you must manually add any custom layers you have created. You can find more information on working with the `bblayers.conf` file in the "[Enabling Your Layer][4181]" section in the Yocto Project Development Manual.
`bblayers.conf` 配置文件告诉 BitBake 在构建过程中要关注那些 layer。默认情况下，在该文件列出的 layer 包含了构建系统需要的最少 layer。然而你必须手动添加任何你自己创建的自定义的 layer 。你可以通过配合 Yocto Project Development Manual 中 [Enabling Your Layer][4181]" 一节的 `bblayers.conf` 获取更多的信息。

The files `site.conf` and `auto.conf` are not created by the environment initialization script. If you want the `site.conf` file, you need to create that yourself. The `auto.conf` file is typically created by an autobuilder:
`site.conf` 和 `auto.conf` 不是由环境初始化脚本创建的。如果你想要 `site.conf` 配置文件，你需要自己创建它。 `auto.conf` 通常是由自动构建器（autobuilder）创建的：

*   _`site.conf`:_  You can use the `conf/site.conf` configuration file to configure multiple build directories. For example, suppose you had several build environments and they shared some common features. You can set these default build properties here. A good example is perhaps the packaging format to use through the [`PACKAGE_CLASSES`][1837] variable.
*   _`site.conf`:_  你可以使用配置文件 `conf/site.conf` 来配置多个构建目录。举个例子，假设你有几个构建环境，而且他们共享一些共同特性。你可以在这里设置这些默认构件属性。一个好例子可能是通过变量  [`PACKAGE_CLASSES`][1837]  设置打包格式。

    One useful scenario for using the `conf/site.conf` file is to extend your [`BBPATH`][1838] variable to include the path to a `conf/site.conf`. Then, when BitBake looks for Metadata using `BBPATH`, it finds the `conf/site.conf` file and applies your common configurations found in the file. To override configurations in a particular build directory, alter the similar configurations within that build directory's `conf/local.conf` file.
    一个有用的场景是使用 `conf/site.conf` 文件扩展你的 [`BBPATH`][1838] 变量，以此来包含 `conf/site.conf` 的路径。然后，当 BitBake 使用 `BBPATH` 查找元数据时，它就会找到文件 `conf/site.conf`，并且应用在这个文件中找到的你的通用配置。要重载特定构建目录的配置，就修改这个构建目录下的 `conf/local.conf` 中相似的配置。

*   _`auto.conf`:_  The file is usually created and written to by an autobuilder. The settings put into the file are typically the same as you would find in the `conf/local.conf` or the `conf/site.conf` files.
*   _`auto.conf`:_ 这个文件经常是由一个自动构建器创建和写入的。文件中的设置通常和你在文件 `conf/local.conf` 或 `conf/site.conf` 中找到的一样。

You can edit all configuration files to further define any particular build environment. This process is represented by the "User Configuration Edits" box in the figure.
你可以修改所有的配置文件为以后定义特殊的构建环境。这个过程在表格中的 "User Configuration Edits" 框展示。

When you launch your build with the `bitbake  _`target`_`  command, BitBake sorts out the configurations to ultimately define your build environment. It is important to understand that the OpenEmbedded build system reads the configuration files in a specific order: `site.conf`, `auto.conf`, and `local.conf`. And, the build system applies the normal assignment statement rules. Because the files are parsed in a specific order, variable assignments for the same variable could be affected. For example, if the `auto.conf` file and the `local.conf` set  _`variable1`_  to different values, because the build system parses `local.conf` after `auto.conf`,  _`variable1`_  is assigned the value from the `local.conf` file.
当你通过 `bitbake  _`target`_` 命令启动你的构建后，BitBake 会对配置文件进行排序，一遍最后定义你的构建环境。理解 OpenEmbedded 构建系统按照特定顺序读取配置文件非常重要：`site.conf`, `auto.conf`, 和 `local.conf`。然后，构建系统会应用普通的赋值语句规则。因为这些文件会按照特定的顺序解析，对同一变量的赋值会受影响。举个例子，如果 `auto.conf` 和 `local.conf` 为变量 _`variable1`_ 赋了不同的值，因为构建系统在 `auto.conf` 之后处理 `local.conf` ，所以 _`variable1`_ 会被赋予了 `local.conf` 文件中的值。

### 3.2. 元数据，机器配置，以及策略配置[¶][818]

The previous section described the user configurations that define BitBake's global behavior. This section takes a closer look at the layers the build system uses to further control the build. These layers provide Metadata for the software, machine, and policy.
前面章节表述了定义 BitBake 的全局动作的用户配置。这一章节会近距离观察构建系统用来控制以后行为的 layer。这些 layer 为软件、机器和策略提供元数据。

In general, three types of layer input exist:
通常来说，存在三种类型的 layer 输入：

*   _Policy Configuration:_  Distribution Layers provide top-level or general policies for the image or SDK being built. For example, this layer would dictate whether BitBake produces RPM or IPK packages.
*   _Policy Configuration:_ 分布的 layer提供构建镜像或者 SDK 的顶层或者通用策略。举个例子，这个 layer 将命令 BitBake 生成 RPM 或者 IPK 软件包。

*   _Machine Configuration:_  Board Support Package (BSP) layers provide machine configurations. This type of information is specific to a particular target architecture.
*   _Machine Configuration:_ BSP layer 提供机器配置。这类信息用来指定特定的目标架构。

*   _Metadata:_  Software layers contain user-supplied recipe files, patches, and append files.
*   _Metadata:_ 软件 layer 包含用户提供的 recipe 文件，补丁和 append 文件。

The following figure shows an expanded representation of the Metadata, Machine Configuration, and Policy Configuration input (layers) boxes of the[general Yocto Project Development Environment figure][4182]:
[general Yocto Project Development Environment figure][4182]，下面的表格展示了一个扩展的表示元数据，机器配置和策略配置的输入（layer）框


![](https://www.yoctoproject.org/docs/current/ref-manual/figures/layer-input.png)


In general, all layers have a similar structure. They all contain a licensing file (e.g. `COPYING`) if the layer is to be distributed, a `README` file as good practice and especially if the layer is to be distributed, a configuration directory, and recipe directories.
通常情况下全部的 layer 有类似的结构。他们全部，如果要发布就包含了版权文件（比如 `COPYING`），作为一个好习惯会有一个 `README` 文件，特别是如果这个 layer 要分发，还会有一个配置目录和和 recipe 目录。

The Yocto Project has many layers that can be used. You can see a web-interface listing of them on the [Source Repositories][4183] page. The layers are shown at the bottom categorized under "Yocto Metadata Layers." These layers are fundamentally a subset of the [OpenEmbedded Metadata Index][4184], which lists all layers provided by the OpenEmbedded community.
Yocto 项目有很多 layer 可以使用。在 [Source Repositories][4183] 页，你可以看到一个 web 接口列出他们。这些 layer 分类显示在 "Yocto Metadata Layers" 底部。这些 layer 根本上是 [OpenEmbedded Metadata Index][4184] 的一个子集，OpenEmbedded Metadata Index 列出了 OpenEmbedded 社区提供的全部 layer。

### Note

Layers exist in the Yocto Project Source Repositories that cannot be found in the OpenEmbedded Metadata Index. These layers are either deprecated or experimental in nature.
在 Yocto 项目原仓库中存在 layer 不会在 OpenEmbedded Metadata Index 中找到。这些 layer 本质上是弃用的的和具有实验性质的。

BitBake uses the `conf/bblayers.conf` file, which is part of the user configuration, to find what layers it should be using as part of the build.
BitBake 使用 `conf/bblayers.conf` 文件，是用户配置文件的一部分，来查找那些 layer 应该作为构建的一部分使用。

For more information on layers, see the "[Understanding and Creating Layers][4185]" section in the Yocto Project Development Manual.
更多关于 layer 的信息参见 Yocto Project Development Manual 的 "[Understanding and Creating Layers][4185]" 章节。

### 3.2.1. 分配 layer[¶][432]

The distribution layer provides policy configurations for your distribution. Best practices dictate that you isolate these types of configurations into their own layer. Settings you provide in `conf/distro/ _`distro`_ .conf` override similar settings that BitBake finds in your `conf/local.conf` file in the Build Directory.
分配的 layer 为你的分配版提供策略配置。最好的命令实践是你讲这些类型的配置文件划分为各自的 layer。你在 `conf/distro/ _`distro`_ .conf` 的设置会覆盖掉 BitBake 在 Build directory 中 `conf/local.conf` 找到的的相似的配置。

The following list provides some explanation and references for what you typically find in the distribution layer:
下面的列表提供了你通常能在分配 layer 中找到的解释和参考：

*   _classes:_  Class files (`.bbclass`) hold common functionality that can be shared among recipes in the distribution. When your recipes inherit a class, they take on the settings and functions for that class. You can read more about class files in the "[Classes][819]" section.
*   _classes:_	Class 文件（`.bbclass`）控制了在分配的 recipe 中可以共享使用的通用功能。当你的 recipe 继承了一个 class，它们会呈现这个 class 的设置和功能。你可以在 "[Classes][819]" 一节读到更多关于 class 文件的信息。


*   _conf:_  This area holds configuration files for the layer (`conf/layer.conf`), the distribution (`conf/distro/ _`distro`_ .conf`), and any distribution-wide include files.
*	_conf:_	 这部分控制了 layer（`conf/layer.conf`）的配置文件，distribution（`conf/distro _`distro`_ .conf`），和 distribution	范围内包含的文件。

*   _recipes-*:_  Recipes and append files that affect common functionality across the distribution. This area could include recipes and append files to add distribution-specific configuration, initialization scripts, custom image recipes, and so forth.
*	_recipes-*：_	Recipe 和 append 文件会在整个 distribution 过程中影响通用功能。这部分能包含 recipe 和 append 文件来添加和 distribution 相关的配置，初始化脚本，自定义镜像 recipe，以及类似的。

### 3.2.2. BSP Layer[¶][433]

The BSP Layer provides machine configurations. Everything in this layer is specific to the machine for which you are building the image or the SDK. A common structure or form is defined for BSP layers. You can learn more about this structure in the [Yocto Project Board Support Package (BSP) Developer's Guide][3771].
BSP layer 提供机器配置。在该 layer 的所有东西都是用于你要构建的镜像和 SDK 的机器。为 BSP layer 定义了一个共同的结构体。你可以在 [Yocto Project Board Support Package (BSP) Developer's Guide][3771] 获取关于这个结构体更多的信息。

### Note

In order for a BSP layer to be considered compliant with the Yocto Project, it must meet some structural requirements.
为了确保一个 BSP layer 和 Yocto 项目匹配，它必须满足依稀结构要求。

The BSP Layer's configuration directory contains configuration files for the machine (`conf/machine/ _`machine`_ .conf`) and, of course, the layer (`conf/layer.conf`).
BSP layer 的配置目录包含机器配置文件（`conf/machine/ _`machine`_ .conf`），以及，当然了还有 layer 配置文件（`conf/layer.conf`）。

The remainder of the layer is dedicated to specific recipes by function: `recipes-bsp`, `recipes-core`, `recipes-graphics`, and `recipes-kernel`. Metadata can exist for multiple formfactors, graphics support systems, and so forth.
剩下的 layer 是专门根据 recpie 功能的：`recipes-bsp`, `recipes-core`, `recipes-graphics`, 和 `recipes-kernel`。元数据存在于多个芯片封装，图形支持系统，以及类似的。

### Note

While the figure shows several `recipes-*` directories, not all these directories appear in all BSP layers.
虽然表格展示了几个 `recipes-*` 目录，但是并不是全部的目录都存在与 BSP layer。

### 3.2.3. 软件 Layer[¶][434]

The software layer provides the Metadata for additional software packages used during the build. This layer does not include Metadata that is specific to the distribution or the machine, which are found in their respective layers.
软件 layer 提供了构建过程中额外软件包的元数据。这个 layer 不包含和 distribution 或及其相关的元数据，这些都可以在他们对应的 layer 找到。

This layer contains any new recipes that your project needs in the form of recipe files.
这个 layer 以 recipe 文件格式提供了你的工程需要的所有新的 recipe。

### 3.3. 源[¶][820]

In order for the OpenEmbedded build system to create an image or any target, it must be able to access source files. The [general Yocto Project Development Environment figure][4186] represents source files using the "Upstream Project Releases", "Local Projects", and "SCMs (optional)" boxes. The figure represents mirrors, which also play a role in locating source files, with the "Source Mirror(s)" box.
为了让 OpenEmbedded 构建系统创建镜像或者任何目标，必须保证能够访问源文件。[general Yocto Project Development Environment figure][4186] 使用 “上游项目发布”，“本地项目”，和 “SCM（可选）”框展示了源文件。这个表格使用 “源镜像”框展示了参与定位源文件的镜像。

The method by which source files are ultimately organized is a function of the project. For example, for released software, projects tend to use tarballs or other archived files that can capture the state of a release guaranteeing that it is statically represented. On the other hand, for a project that is more dynamic or experimental in nature, a project might keep source files in a repository controlled by a Source Control Manager (SCM) such as Git. Pulling source from a repository allows you to control the point in the repository (the revision) from which you want to build software. Finally, a combination of the two might exist, which would give the consumer a choice when deciding where to get source files.
对源文件最根本的组织方法是按照项目的功能。举个例子，对于发布的软件，项目趋向于使用 tar 包或者其他可以捕获发布状态的压缩包，这样能保证它是静态展示的。另一方面，对于本质上更动态或者实验性质的项目，一个项目可能会使用源码管理器（SCM）的仓库来保存源文件，比如 git。从仓库拉取代码可能保证你控制你想要构建的软件的仓库版本。最后，这两种的组合也可能存在，这会让用户选择从哪里获取源代码。

BitBake uses the [`SRC_URI`][4187] variable to point to source files regardless of their location. Each recipe must have a `SRC_URI` variable that points to the source.
BitBake 使用变量 [`SRC_URI`][4187] 指向源文件而忽视他们的位置。每个 recipe 必须有一个 `SRC_URI` 变量指向源代码。

Another area that plays a significant role in where source files come from is pointed to by the [`DL_DIR`][4188] variable. This area is a cache that can hold previously downloaded source. You can also instruct the OpenEmbedded build system to create tarballs from Git repositories, which is not the default behavior, and store them in the `DL_DIR` by using the [`BB_GENERATE_MIRROR_TARBALLS`][4189] variable.
另一个在源文件中起重要角色的区域是由 [`DL_DIR`][4188]指向的。这个区域是之前下载下来的源代码的缓存。你可以命令 OpenEmbedded 构建系统从 Git 仓库创建压缩包，这并不是默认行为，然后通过变量 [`BB_GENERATE_MIRROR_TARBALLS`][4189] 把它们保存到 `DL_DIR` 目录。

Judicious use of a `DL_DIR` directory can save the build system a trip across the Internet when looking for files. A good method for using a download directory is to have `DL_DIR` point to an area outside of your Build Directory. Doing so allows you to safely delete the Build Directory if needed without fear of removing any downloaded source file.
明智的使用 `DL_DIR` 目录可以减少构建系统从网上搜寻文件的时间。使用下载目录的好行为是将 `DL_DIR` 指向 Build Directory 之外的区域。这样做可以让你安全地删除 Build Directory 而不需要害怕删除了已经下载了的源文件。

The remainder of this section provides a deeper look into the source files and the mirrors. Here is a more detailed look at the source file area of the base figure:
剩下的章节会深入观察源文件和镜像。这里是一个更详细基础表格的源码文件区域：

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/source-input.png)

### 3.3.1. 上游项目发布[¶][435]

Upstream project releases exist anywhere in the form of an archived file (e.g. tarball or zip file). These files correspond to individual recipes. For example, the figure uses specific releases each for BusyBox, Qt, and Dbus. An archive file can be for any released product that can be built using a recipe.
上游项目以压缩文件形式（比如 tar 或者 zip）发布在任何地方。这些文件对应单独的 recipe。举个例子，表格对每个 BusyBox，Qt 和 Dbus 使用特定版本。任何可以用recipe构建的发布产品都可以使用压缩文件。

### 3.3.2. 本地工程[¶][436]

Local projects are custom bits of software the user provides. These bits reside somewhere local to a project - perhaps a directory into which the user checks in items (e.g. a local directory containing a development source tree used by the group).
本地工程是用户提供的自定义的软件。这些代码保存在本地工程 - 可能是用户签出的条目的目录（比如，本地目录包含一个组的开发源代码树）。

The canonical method through which to include a local project is to use the [`externalsrc`][3772] class to include that local project. You use either the `local.conf` or a recipe's append file to override or set the recipe to point to the local directory on your disk to pull in the whole source tree.
包含一个本地工程的正规方法是使用 [`externalsrc`][3772] class 来引入本地工程。你要么使用 `local.conf` ，或者一个 recipe 的 append 文件重载，或者设置 recipe 指向本地磁盘目录来拉取整个代码树。

For information on how to use the `externalsrc` class, see the "[`externalsrc.bbclass`][3773]" section.
更多关于如何使用 `externalsrc` class 的信息参见 "[`externalsrc.bbclass`][3773]" 一节。

### 3.3.3.源码控制器 (可选项)[¶][437]

Another place the build system can get source files from is through an SCM such as Git or Subversion. In this case, a repository is cloned or checked out. The [`do_fetch`][3774] task inside BitBake uses the [`SRC_URI`][3775] variable and the argument's prefix to determine the correct fetcher module.
另一个构建系统可以获得源代码文件的形式是通过源码管理器，比如 Git 或者 Subversion。这种情况下，一个仓库就是克隆或者签出的。BitBake 中的 [`do_fetch`][3774] task 使用变量 [`SRC_URI`][3775] 和参数的前缀来选择正确的拉取模块。

### Note

For information on how to have the OpenEmbedded build system generate tarballs for Git repositories and place them in the [`DL_DIR`][3776]directory, see the [`BB_GENERATE_MIRROR_TARBALLS`][3777] variable.
要获取关于如何让 OpenEmbedded 构建系统产生 Git 仓库的 tar 包然后放到 [`DL_DIR`][3776] 目录的信息，参见变量 [`BB_GENERATE_MIRROR_TARBALLS`][3777]。

When fetching a repository, BitBake uses the [`SRCREV`][3778] variable to determine the specific revision from which to build.
当拉取一个仓库时，BitBake 使用变量 [`SRCREV`][3778] 来决定构建时要使用的版本。

### 3.3.4. 源码镜像[¶][438]

Two kinds of mirrors exist: pre-mirrors and regular mirrors. The [`PREMIRRORS`][3779] and [`MIRRORS`][3780] variables point to these, respectively. BitBake checks pre-mirrors before looking upstream for any source files. Pre-mirrors are appropriate when you have a shared directory that is not a directory defined by the [`DL_DIR`][3781] variable. A Pre-mirror typically points to a shared directory that is local to your organization.
存在两种类型的镜像：预先镜像和常规镜像。变量 [`PREMIRRORS`][3779] 和 [`MIRRORS`][3780] 分别指向对应的路径。BitBake 会在上游源码之前检查 pre-mirrors。pre-mirrors 很适合用于当你有一个不是由变量 [`DL_DIR`][3781] 定义的共享目录。一个 pre-mirrors 通常指向你的组织的本地的共享目录。

Regular mirrors can be any site across the Internet that is used as an alternative location for source code should the primary site not be functioning for some reason or another.
常规镜像可以是任何因特网上的站点，用来作为源码的主站的因为某些原因不可用时的替代。

### 3.4. 软件包源[¶][821]

When the OpenEmbedded build system generates an image or an SDK, it gets the packages from a package feed area located in the [Build Directory][4190]. The [general Yocto Project Development Environment figure][4191] shows this package feeds area in the upper-right corner.
当 OpenEmbedded 构建系统制造一个镜像或者 SDK 时，它会从位于 [Build Directory][4190] 的软件包源区获取软件包。

This section looks a little closer into the package feeds area used by the build system. Here is a more detailed look at the area:
本节稍微进一步观察用于构建系统的软件包源区。下面是这个却与更详细的介绍：

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/package-feeds.png)

Package feeds are an intermediary step in the build process. The OpenEmbedded build system provides classes to generate different package types, and you specify which classes to enable through the [`PACKAGE_CLASSES`][4192] variable. Before placing the packages into package feeds, the build process validates them with generated output quality assurance checks through the [`insane`][4193] class.
软件包源是构建过程的中间步骤。OpenEmbedded 构建系统提供了 class 来产生不同的软件包类型，你可以通过变量 [`PACKAGE_CLASSES`][4192] 使能 class。在将软件包放到软件包源区之前，构建系统会通过 [`insane`][4193] class 检查生成的输出质量保证来验证这些软件包。

The package feed area resides in the Build Directory. The directory the build system uses to temporarily store packages is determined by a combination of variables and the particular package manager in use. See the "Package Feeds" box in the illustration and note the information to the right of that area. In particular, the following defines where package files are kept:
软件包源区位于 Build Directory。构建系统使用那个目录来临时保存软件包是通过变量和使用的特定包管理器一起决定的。参见图示的 "Package Feeds" 框，注意右边的信息。特别是，下面定义了软件包保存的位置：

*   [`DEPLOY_DIR`][1839]: Defined as `tmp/deploy` in the Build Directory.
*	[`DEPLOY_DIR`][1839]: 定义为 Build Directory 的 `tmp/deploy`。

*   `DEPLOY_DIR_*`: Depending on the package manager used, the package type sub-folder. Given RPM, IPK, or DEB packaging and tarball creation, the[`DEPLOY_DIR_RPM`][1840], [`DEPLOY_DIR_IPK`][1841], [`DEPLOY_DIR_DEB`][1842], or [`DEPLOY_DIR_TAR`][1843], variables are used, respectively.
*	`DEPLOY_DIR_*`: 根据使用的包管理器，软件包类型子文件夹爱。已有的是 RPM，IPK，或者 DEB 打包，以及 tar 包创建，分别使用了变量 [`DEPLOY_DIR_RPM`][1840], [`DEPLOY_DIR_IPK`][1841], [`DEPLOY_DIR_DEB`][1842], or [`DEPLOY_DIR_TAR`][1843]。

*   [`PACKAGE_ARCH`][1844]: Defines architecture-specific sub-folders. For example, packages could exist for the i586 or qemux86 architectures.
*	[`PACKAGE_ARCH`][1844]: 定义了架构相关的子文件夹。举个例子，可能存在 i586 或者 qemux86 架构的软件包。

BitBake uses the `do_package_write_*` tasks to generate packages and place them into the package holding area (e.g. `do_package_write_ipk` for IPK packages). See the "[`do_package_write_deb`][4194]", "[`do_package_write_ipk`][4195]", "[`do_package_write_rpm`][4196]", and "[`do_package_write_tar`][4197]" sections for additional information. As an example, consider a scenario where an IPK packaging manager is being used and package architecture support for both i586 and qemux86 exist. Packages for the i586 architecture are placed in `build/tmp/deploy/ipk/i586`, while packages for the qemux86 architecture are placed in `build/tmp/deploy/ipk/qemux86`.
BitBake 是由 `do_package_write_*` tasks 来生成软件包，并且把它们放到包保存区（比如对于 IPK 包就是 `do_package_write_ipk`）。参见 "[`do_package_write_deb`][4194]", "[`do_package_write_ipk`][4195]", "[`do_package_write_rpm`][4196]" 和 "[`do_packag e_write_tar`][4197]" 一节来获取额外信息。作为一个例子，考虑下面的情形，使用了 IPK 包管理器，软件包支持 i586 和 qemux86 两种架构。为 i586 架构准备的软件包保存在 `build/tmp/deploy/ipk/i586`，而 qemux86 架构的软件包保存在 `build/tmp/deploy/ipk/qemux86`。

### 3.5. BitBake[¶][822]

The OpenEmbedded build system uses [BitBake][4198] to produce images. You can see from the [general Yocto Project Development Environment figure][4199], the BitBake area consists of several functional areas. This section takes a closer look at each of those areas.
OpenEmbedded 构建系统使用 [BitBake][4198] 生成镜像。你可以参考 [general Yocto Project Development Environment figure][4199]，BitBake 区由几个功能区组成。本节近距离观察每个区域。

Separate documentation exists for the BitBake tool. See the [BitBake User Manual][4200] for reference material on BitBake.
有单独的关于 BitBake 的文档。可以看 [BitBake User Manual][4200] 作为 BitBake 的参考资料。

### 3.5.1. 获取源码[¶][439]

The first stages of building a recipe are to fetch and unpack the source code:
构建 recipe 的第一个阶段是获取和解压源代码：

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/source-fetching.png)

The [`do_fetch`][3782] and [`do_unpack`][3783] tasks fetch the source files and unpack them into the work directory.
[`do_fetch`][3782] 和 [`do_unpack`][3783] task 获取代码并解压到工作目录。

### Note

For every local file (e.g. `file://`) that is part of a recipe's [`SRC_URI`][3784] statement, the OpenEmbedded build system takes a checksum of the file for the recipe and inserts the checksum into the signature for the `do_fetch`. If any local file has been modified, the `do_fetch`task and all tasks that depend on it are re-executed.
对于所有是 recipe 的 [`SRC_URI`][3784] 语句的一部分的每个本地文件（比如 `file://`)，OpenEmbedded 构建系统都会获取 recipe 对应的文件校验和，并将校验和插入到 `do_fetch` 的签名。如果任何本地文件被修改了， `do_fetch` task 和所有依赖于它的 task 都会重新执行。

By default, everything is accomplished in the [Build Directory][3785], which has a defined structure. For additional general information on the Build Directory, see the "[`build/`][3786]" section.
默认情况下，所有事都在 [Build Directory][3785] 中完成，这有一个定义好的结构体。关于 Build Directory 的更多的通用信息参见 "[`build/`][3786]" 一节。

Unpacked source files are pointed to by the [`S`][3787] variable. Each recipe has an area in the Build Directory where the unpacked source code resides. The name of that directory for any given recipe is defined from several different variables. You can see the variables that define these directories by looking at the figure:

*   [`TMPDIR`][823] - The base directory where the OpenEmbedded build system performs all its work during the build.

*   [`PACKAGE_ARCH`][824] - The architecture of the built package or packages.

*   [`TARGET_OS`][825] - The operating system of the target device.

*   [`PN`][826] - The name of the built package.

*   [`PV`][827] - The version of the recipe used to build the package.

*   [`PR`][828] - The revision of the recipe used to build the package.

*   [`WORKDIR`][829] - The location within `TMPDIR` where a specific package is built.

*   [`S`][830] - Contains the unpacked source files for a given recipe.

### 3.5.2. Patching[¶][440]

Once source code is fetched and unpacked, BitBake locates patch files and applies them to the source files:

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/patching.png)

The [`do_patch`][3788] task processes recipes by using the [`SRC_URI`][3789] variable to locate applicable patch files, which by default are `*.patch` or `*.diff` files, or any file if "apply=yes" is specified for the file in `SRC_URI`.

BitBake finds and applies multiple patches for a single recipe in the order in which it finds the patches. Patches are applied to the recipe's source files located in the [`S`][3790] directory.

For more information on how the source directories are created, see the "[Source Fetching][3791]" section.

### 3.5.3. Configuration and Compilation[¶][441]

After source code is patched, BitBake executes tasks that configure and compile the source code:

 
![](https://www.yoctoproject.org/docs/current/ref-manual/figures/configuration-compile-autoreconf.png)
 

This step in the build process consists of three tasks:

*   _[`do_prepare_recipe_sysroot`][29]:_  This task sets up the two sysroots in `${`[`WORKDIR`][831]`}` (i.e. `recipe-sysroot` and `recipe-sysroot-native`) so that the sysroots contain the contents of the [`do_populate_sysroot`][832] tasks of the recipes on which the recipe containing the tasks depends. A sysroot exists for both the target and for the native binaries, which run on the host system.

*   _`do_configure`:_  This task configures the source by enabling and disabling any build-time and configuration options for the software being built. Configurations can come from the recipe itself as well as from an inherited class. Additionally, the software itself might configure itself depending on the target for which it is being built.
*   _`do_configure`:_  这个任务通过对要构建的软件的源使能和禁止任何构建时和配置选项进行配置。配置可以从 recipe 自身，也可以从继承的 class 得到。此外，软件本身也会根据要构建的架构配置自己。

    The configurations handled by the [`do_configure`][833] task are specific to source code configuration for the source code being built by the recipe.
    由 [`do_configure`][833] task 处理的配置和源码配置相关，这些配置会用于构建 recipe。

    If you are using the [`autotools`][834] class, you can add additional configuration options by using the [`EXTRA_OECONF`][835] or [`PACKAGECONFIG_CONFARGS`][836]variables. For information on how this variable works within that class, see the `meta/classes/autotools.bbclass` file.
    如果你使用 [`autotools`][834] class，你可以通过变量 [`EXTRA_OECONF`][835] 或 [`PACKAGECONFIG_CONFARGS`][836] 添加额外的配置项。更多关于这个 class 的信息可以参考 `meta/classes/autotools.bbclass`。

*   _`do_compile`:_  Once a configuration task has been satisfied, BitBake compiles the source using the [`do_compile`][837] task. Compilation occurs in the directory pointed to by the [`B`][838] variable. Realize that the `B` directory is, by default, the same as the [`S`][839] directory.
*   _`do_compile`:_ 一旦配置 task 满足了了，BitBake 通过 [`do_compile`][837] task 编译源码。编译在变量 [`B`][838] 指向的目录进行。认识到 `B` 目录默认是和 [`S`][839] 目录一样。

*   _`do_install`:_  Once compilation is done, BitBake executes the [`do_install`][840] task. This task copies files from the `B` directory and places them in a holding area pointed to by the [`D`][841] variable.
*   _`do_install`:_ 一旦编译完成， BitBake 执行 [`do_install`][840] task。这个 task 会从目录 `B` 拷贝到变量 [`D`][841] 指向的区域。

### 3.5.4. 软件包分割[¶][442]

After source code is configured and compiled, the OpenEmbedded build system analyzes the results and splits the output into packages:
在源代码配置和编译之后，OpenEmbedded 构建系统分析结果，然后将输出分割到软件包

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/analysis-for-package-splitting.png)

The [`do_package`][3792] and [`do_packagedata`][3793] tasks combine to analyze the files found in the [`D`][3794] directory and split them into subsets based on available packages and files. The analyzing process involves the following as well as other items: splitting out debugging symbols, looking at shared library dependencies between packages, and looking at package relationships. The `do_packagedata` task creates package metadata based on the analysis such that the OpenEmbedded build system can generate the final packages. Working, staged, and intermediate results of the analysis and package splitting process use these areas:
[`do_package`][3792] 和 [`do_packagedata`][3793] task 一起分析在目录 [`D`][3794] 中找到的文件并根据可用的包和文件将它们分割成子集 。这个分析过程涉及下面的以及其他的条目：分割调试信息，检查软件包之间的共享库依赖，以及查看包之间的关系。`do_packagedata` task 根据分析的结果创建包元数据，比如 OpenEmbedded 构建系统可以产生最终的包。工作的，阶段的，和分析的中间结果和分割包过程使用这些区域：

*   [`PKGD`][842] - The destination directory for packages before they are split.
*   [`PKGD`][842] - 包在分割之前的目的目录。

*   [`PKGDATA_DIR`][843] - A shared, global-state directory that holds data generated during the packaging process.
*   [`PKGDATA_DIR`][843] - 一个共享的，全局状态目录，保存了打包过程产生的数据。

*   [`PKGDESTWORK`][844] - A temporary work area used by the `do_package` task.
*   [`PKGDESTWORK`][844] - 一个用于 `do_package` task 的临时工作区。

*   [`PKGDEST`][845] - The parent directory for packages after they have been split.
*   [`PKGDEST`][845] - 包分割之后的父目录。

The [`FILES`][3795] variable defines the files that go into each package in [`PACKAGES`][3796]. If you want details on how this is accomplished, you can look at the[`package`][3797] class.
变量 [`FILES`][3795] 定义了要打包到每个在 [`PACKAGES`][3796] 的软件包的文件。如果你想要详细了解这是怎么完成的，你可以看一看 [`package`][3797] class。

Depending on the type of packages being created (RPM, DEB, or IPK), the `do_package_write_*` task creates the actual packages and places them in the Package Feed area, which is `${TMPDIR}/deploy`. You can see the "[Package Feeds][3798]" section for more detail on that part of the build process.
根据要创建的包的类型（RPM，DEB 或 IPK），`do_package_write_*` task 创建了实际的包并将它们放到 Package Feed 区域，也就是 `${TMPDIR}/deploy`。你可以看看 "[Package Feeds][3798]" 一节了解更详细的关于构建过程的信息。

### Note

Support for creating feeds directly from the `deploy/*` directories does not exist. Creating such feeds usually requires some kind of feed maintenance mechanism that would upload the new packages into an official package feed (e.g. the Ångström distribution). This functionality is highly distribution-specific and thus is not provided out of the box.
不存在支持从目录 `deploy/*` 直接创造 feeds。创建这种 feed 通常需要一些种类的 feed 维护机制，可以上传新的软件包到官方软件包 feed（比如，Angstrom 发行版）。这个功能是和特定发行版相关，因此不提供超出框架的东西。

### 3.5.5. 生成镜像[¶][443]

Once packages are split and stored in the Package Feeds area, the OpenEmbedded build system uses BitBake to generate the root filesystem image:
一个软件包会被分割并存储在 Package Feeds 区域， OpenEmbedded 构建系统使用 BitBake 生成根文件系统镜像。

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/image-generation.png)

The image generation process consists of several stages and depends on several tasks and variables. The [`do_rootfs`][3799] task creates the root filesystem (file and directory structure) for an image. This task uses several key variables to help create the list of packages to actually install:
镜像产生过程包括几个阶段，依赖于不同的 task 和变量。[`do_rootfs`][3799] task 创建镜像的根文件系统（文件和目录结构）。这个 task 使用几个关键变量帮助创建实际安装的包的列表：

*   [`IMAGE_INSTALL`][846]: Lists out the base set of packages to install from the Package Feeds area.
*   [`IMAGE_INSTALL`][846]: 列出要从 Package Feed 区域安装的基础包集合。

*   [`PACKAGE_EXCLUDE`][847]: Specifies packages that should not be installed.
*   [`PACKAGE_EXCLUDE`][847]: 指定不应该安装的包。

*   [`IMAGE_FEATURES`][848]: Specifies features to include in the image. Most of these features map to additional packages for installation.
*   [`IMAGE_FEATURES`][848]: 指定应该包含进镜像的特性。安装时大多数特性映射到额外的包。

*   [`PACKAGE_CLASSES`][849]: Specifies the package backend to use and consequently helps determine where to locate packages within the Package Feeds area.
*   [`PACKAGE_CLASSES`][849]: 制定了要用的包后端，接着帮助确定在 Package Feed 区域哪里找到软件包。

*   [`IMAGE_LINGUAS`][850]: Determines the language(s) for which additional language support packages are installed.
*   [`IMAGE_LINGUAS`][850]: 决定要安装那些额外的语言支持包。

*   [`PACKAGE_INSTALL`][851]: The final list of packages passed to the package manager for installation into the image.
*   [`PACKAGE_INSTALL`][851]: 最后传给包管理器的要安装到镜像的包的列表。

With [`IMAGE_ROOTFS`][3800] pointing to the location of the filesystem under construction and the `PACKAGE_INSTALL` variable providing the final list of packages to install, the root file system is created.
因为 [`IMAGE_ROOTFS`][3800] 指向了正在构建的文件系统的位置， 变量 `PACKAGE_INSTALL` 提供了最后要安装的包的列表，根文件系统就创建好了。

Package installation is under control of the package manager (e.g. dnf/rpm, opkg, or apt/dpkg) regardless of whether or not package management is enabled for the target. At the end of the process, if package management is not enabled for the target, the package manager's data files are deleted from the root filesystem. As part of the final stage of package installation, postinstall scripts that are part of the packages are run. Any scripts that fail to run on the build host are run on the target when the target system is first booted. If you are using a [read-only root filesystem][3801], all the post installation scripts must succeed during the package installation phase since the root filesystem is read-only.
包的安装是在包管理器（比如 dnf/rpm，opkg，或者apt/dpkg）的控制下进行的，不关注包管理器是否在目标使能了。过程的最后，如果包管理器没有为目标使能，这个包管理器的数据文件就会从根文件系统删除。作为包安装的最后一个阶段，安装后脚本时要运行的包的一部分。所有在构建筑上运行失败的脚本需要在目标系统第一次启动时运行。如果你使用了[只读根文件系统][3801]所有的安装后脚本必须在包安装阶段成功执行，因为这个根文件系统是只读的。

The final stages of the `do_rootfs` task handle post processing. Post processing includes creation of a manifest file and optimizations.
`do_rootfs` task 的最后简短要控制处理后的工作。处理后的工作包括创建清单文件和优化工作。

The manifest file (`.manifest`) resides in the same directory as the root filesystem image. This file lists out, line-by-line, the installed packages. The manifest file is useful for the [`testimage`][3802] class, for example, to determine whether or not to run specific tests. See the [`IMAGE_MANIFEST`][3803] variable for additional information.
清单文件（`.manifest`）位于根文件系统镜像同一个目录。这个文件按行列出了安装了的软件包。这个清单文件对 [`testimage`][3802] class 很有用，举个例子，要决定是否执行特定的测试。详细信息参见变量 [`IMAGE_MANIFEST`][3803]。

Optimizing processes run across the image include `mklibs`, `prelink`, and any other post-processing commands as defined by the[`ROOTFS_POSTPROCESS_COMMAND`][3804] variable. The `mklibs` process optimizes the size of the libraries, while the `prelink` process optimizes the dynamic linking of shared libraries to reduce start up time of executables.
优化过程运行整个镜像，包括 `mklibs`, `prelink`，和全部其它定义在变量 [`ROOTFS_POSTPROCESS_COMMAND`][3804] 中的处理后命令。`mklibs` 优化库文件的大小，而 `prelink` 又换共享库的动态链接，减少可执行文件的启动时间。

After the root filesystem is built, processing begins on the image through the `do_image` task. The build system runs any pre-processing commands as defined by the [`IMAGE_PREPROCESS_COMMAND`][3805] variable. This variable specifies a list of functions to call before the OpenEmbedded build system creates the final image output files.
在根文件系统构件好之后，通过 `do_image` task 开始处理镜像。构建系统运行变量 [`IMAGE_PREPROCESS_COMMAND`][3805] 定义的全部的处理前命令。这个变量制定了一串要在 OpenEmbedded 构建系统创建最终镜像输出文件之前执行的函数。

The `do_image` task dynamically creates other `do_image_*` tasks as needed, which include compressing the root filesystem image to reduce the overall size of the image. The process turns everything into an image file or a set of image files. The formats used for the root filesystem depend on the[`IMAGE_FSTYPES`][3806] variable.
`do_image` task 按需动态创建其它 `do_image_*` tasks，包括压缩根文件系统镜像来减少镜像的总体积。这个过程将所有东西变成一个镜像文件或者一组镜像文件。根文件系统的格式根据变量 [`IMAGE_FSTYPES`][3806] 而定。

The final task involved in image creation is the `do_image_complete` task. This task completes the image by applying any image post processing as defined through the [`IMAGE_POSTPROCESS_COMMAND`][3807] variable. The variable specifies a list of functions to call once the OpenEmbedded build system has created the final image output files.
最后的设计创建镜像的 task 是 `do_image_complete`。这个 task 通过应用在变量 [`IMAGE_POSTPROCESS_COMMAND`][3807] 定义的全部镜像处理后工作来完成镜像。这个变量指定了一系列的函数，一旦 OpenEmbedded 构建系统创建完镜像输出文件就会调用。

### Note

The entire image generation process is run under Pseudo. Running under Pseudo ensures that the files in the root filesystem have correct ownership.
整个镜像生成过程都运行在 Pseudo 状态。在 Pseudo 状态下运行可以保证根文件系统中的全部文件都有正确的所有权。


### 3.5.6. SDK 生成[¶][444]

The OpenEmbedded build system uses BitBake to generate the Software Development Kit (SDK) installer script for both the standard and extensible SDKs: 
OpenEmbedded 构建系统使用 BitBake 产生标准的和扩展的软件开发工具（SDK） 安装脚本：

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/sdk-generation.png)

### Note

For more information on the cross-development toolchain generation, see the "[Cross-Development Toolchain Generation][3808]" section. For information on advantages gained when building a cross-development toolchain using the [`do_populate_sdk`][3809] task, see the "[Building an SDK Installer][3810]" section in the Yocto Project Software Development Kit (SDK) Developer's Guide.
更多关于生成交叉编译工具链的信息参见 "[Cross-Development Toolchain Generation][3808]" 一节。关于使用 [`do_populate_sdk`][3809] task 构建交叉编译工具链的高级经验参见 Yocto Project Software Development Kit (SDK) Developer's Guide 的 "[Building an SDK Installer][3810]" 一节。

Like image generation, the SDK script process consists of several stages and depends on many variables. The `do_populate_sdk` and`do_populate_sdk_ext` tasks use these key variables to help create the list of packages to actually install. For information on the variables listed in the figure, see the "[Application Development SDK][3811]" section.
类似于镜像生成， SDK 脚本红醋栗包括几个阶段，依赖于很多变量。`do_populate_sdk` 和 `do_populate_sdk_ext` task 使用这些关键变量帮助创建实际安装的包的列表。关于表中列出的变量的信息参见 "[Application Development SDK][3811]" 一节。

The `do_populate_sdk` task helps create the standard SDK and handles two parts: a target part and a host part. The target part is the part built for the target hardware and includes libraries and headers. The host part is the part of the SDK that runs on the [`SDKMACHINE`][3812].
`do_populate_sdk` task 帮助创建标准的 SDK，处理两个部分：目标部分和主机部分。目标部分是为目标硬件构建的，包括了库和头文件。主机部分是运行在 [`SDKMACHINE`][3812] 上的 SDK。

The `do_populate_sdk_ext` task helps create the extensible SDK and handles host and target parts differently than its counter part does for the standard SDK. For the extensible SDK, the task encapsulates the build system, which includes everything needed (host and target) for the SDK.
`do_populate_sdk_ext` task 帮助创建可扩展的 SDK 并处理处理主机和目标部分不同于标准 SDK 的对应部分。对于可扩展的 SDK，这个 task 封装了包括 SDK 需要的全部东西（主机和目标）的构建系统。

Regardless of the type of SDK being constructed, the tasks perform some cleanup after which a cross-development environment setup script and any needed configuration files are created. The final output is the Cross-development toolchain installation script (`.sh` file), which includes the environment setup script.
不管要构造那种 SDK， 这些 task 都会在交叉编译环境设置脚本和需要的配置文件创建好之后执行清理工作。最后的输出的是包含环境设置脚本的交叉开发工具链安装脚本（`.sh` 文件）。

### 3.5.7. 时间戳文件和重新运行 task[¶][445]

For each task that completes successfully, BitBake writes a stamp file into the [`STAMPS_DIR`][3813] directory. The beginning of the stamp file's filename is determined by the [`STAMP`][3814] variable, and the end of the name consists of the task's name and current [input checksum][3815].
对于每个成功完成的 task， BitBake 都会在 [`STAMPS_DIR`][3813] 目录写一个时间戳文件。时间戳文件的的文件名以变量 [`STAMP`][3814] 开始， 文件名的结束由 task 的名字和当前的输入 [校验和][3815] 组成。

### Note

This naming scheme assumes that [`BB_SIGNATURE_HANDLER`][3816] is "OEBasicHash", which is almost always the case in current OpenEmbedded.
这个命名模式假设了 [`BB_SIGNATURE_HANDLER`][3816] 是 "OEBasicHash"，当前 OpenEmbedded 几乎都是这种模式。

To determine if a task needs to be rerun, BitBake checks if a stamp file with a matching input checksum exists for the task. If such a stamp file exists, the task's output is assumed to exist and still be valid. If the file does not exist, the task is rerun.
要决定一个 task 是否需要重新运行， BitBake 要检查是否存在匹配 task 的输入校验和的时间戳文件。如果这样一个时间戳文件存在，则这个 task 的输出被假设是存在并且有效的。如果这个文件不存在，则 task 要重新运行。

### Note

The stamp mechanism is more general than the shared state (sstate) cache mechanism described in the "[Setscene Tasks and Shared State][3456]" section. BitBake avoids rerunning any task that has a valid stamp file, not just tasks that can be accelerated through the sstate cache.
时间戳机制比在 "[Setscene Tasks and Shared State][3456]" 一节描述的 共享状态（sstate）缓存机制更常用。 BitBake 避免重新运行一个有有效时间戳文件的 task，不仅仅因为 task 可以通过 sstate 缓存加速。

However, you should realize that stamp files only serve as a marker that some work has been done and that these files do not record task output. The actual task output would usually be somewhere in [`TMPDIR`][3457] (e.g. in some recipe's [`WORKDIR`][3458].) What the sstate cache mechanism adds is a way to cache task output that can then be shared between build machines.
然而，你应该意识到这些时间戳文件只是标记某些工作已经做过了，这些文件不会记录 task 的输出。实际的 task 输出将通常在 [`TMPDIR`][3457] 的某些地方（比如在一些 recipe 的 [`WORKDIR`][3458]）。sstate 缓存机制增加了一个缓存 task 输出的途径，这样输出就可以在构建机器之间共享。

Since `STAMPS_DIR` is usually a subdirectory of `TMPDIR`, removing `TMPDIR` will also remove `STAMPS_DIR`, which means tasks will properly be rerun to repopulate `TMPDIR`.
因为 `STAMPS_DIR` 通常是 `TMPDIR` 的子目录，删除 `TMPDIR` 将同样删除了 `STAMPS_DIR`，这就意味着 task 可能要重新运行来重新生成 `TMPDIR`。

If you want some task to always be considered "out of date", you can mark it with the [`nostamp`][3817] varflag. If some other task depends on such a task, then that task will also always be considered out of date, which might not be what you want.
如果你想要 task 总被认为过期了，你可以给她使用标志 [`nostamp`][3817]。如果其它 task 依赖这样一个 task，然后这个 task 总会被认为过期，这可能并不是你想要的。

For details on how to view information about a task's signature, see the "[Viewing Task Variable Dependencies][3818]" section.
关于如何查看一个 task 签名的信息，参见 "[Viewing Task Variable Dependencies][3818]" 一节。

### 3.5.8. Setscene Tasks and Shared State[¶][446]

The description of tasks so far assumes that BitBake needs to build everything and there are no prebuilt objects available. BitBake does support skipping tasks if prebuilt objects are available. These objects are usually made available in the form of a shared state (sstate) cache.
到目前为止对 task 的描述都是假设 BitBake 需要构建所有东西，而且没有可用的构件好的对象。 BitBake 支持在有可用的构件好的对象是跳过该步骤。这些对象通常是以共享状态（sstate）缓存的形式可用的。

### Note

For information on variables affecting sstate, see the [`SSTATE_DIR`][3819] and [`SSTATE_MIRRORS`][3820] variables.
关于影响 sstate 的变量，参见 [`SSTATE_DIR`][3819] 和 [`SSTATE_MIRRORS`][3820] 变量。

The idea of a setscene task (i.e `do_` _`taskname`_ `_setscene`) is a version of the task where instead of building something, BitBake can skip to the end result and simply place a set of files into specific locations as needed. In some cases, it makes sense to have a setscene task variant (e.g. generating package files in the `do_package_write_*` task). In other cases, it does not make sense, (e.g. a [`do_patch`][3821] task or [`do_unpack`][3822] task) since the work involved would be equal to or greater than the underlying task.
设置场景 task（比如 `do_` _`taskname`_ `_setscene`）是替代构建某个东西的 task的版本， BitBake 可以跳过直接到结果，按需简单的放置一组文件到特定的位置。在某些情况下，有一个设置场景 task 变体也这说得通（比如在 `do_package_write_*` task 中产生包文件）。在其他情况下，就说不通了，（比如一个 [`do_patch`][3821] task 或 [`do_unpack`][3822] task）因为这些涉及道德等于或超过了底层 task。

In the OpenEmbedded build system, the common tasks that have setscene variants are [`do_package`][3823], `do_package_write_*`, [`do_deploy`][3824],[`do_packagedata`][3825], and [`do_populate_sysroot`][3826]. Notice that these are most of the tasks whose output is an end result.
在 OpenEmbedde 构建系统，通常由设置场景变体的 task 是 [`do_package`][3823], `do_package_write_*`, [`do_deploy`][3824],[`do_packagedata`][3825], 和 [`do_populate_sysroot`][3826]。注意大部分这些 task 的输出都是最终结果。

The OpenEmbedded build system has knowledge of the relationship between these tasks and other tasks that precede them. For example, if BitBake runs `do_populate_sysroot_setscene` for something, there is little point in running any of the `do_fetch`, `do_unpack`, `do_patch`, `do_configure`,`do_compile`, and `do_install` tasks. However, if `do_package` needs to be run, BitBake would need to run those other tasks.
OpenEmbedded 构建爱你系统由这些 task 和其它之前的 task 的关系的信息。举个例子， BitBake 为了某件事运行 `do_populate_sysroot_setscene`，这就几乎没有指向运行中的 `do_fetch`, `do_unpack`, `do_patch`, `do_configure`,`do_compile`, and `do_install` task。然而，如果 `do_package`需要运行， BitBake 将需要运行其它 task。

It becomes more complicated if everything can come from an sstate cache because some objects are simply not required at all. For example, you do not need a compiler or native tools, such as quilt, if there is nothing to compile or patch. If the `do_package_write_*` packages are available from sstate, BitBake does not need the `do_package` task data.
如果全部事情都能从 sstate 缓存得到，事情就变得复杂了，因为有些对象就完全不是需要的了。举个例子，你不需要一个编译器或者本地工具，比如被子，如果没有任何东西要编译或者打补丁。如果 `do_package_write_*` 软件包可以从 sstate获取， BitBake 就不需要 `do_package` task 的数据。

To handle all these complexities, BitBake runs in two phases. The first is the "setscene" stage. During this stage, BitBake first checks the sstate cache for any targets it is planning to build. BitBake does a fast check to see if the object exists rather than a complete download. If nothing exists, the second phase, which is the setscene stage, completes and the main build proceeds.
要处理全部这些复杂性， BitBake 运行在两个阶段。第一个是 "设置场景" 阶段。在这个阶段，BitBake 首先为全部计划要构建的目标检查 sstate 缓存。 BitBake 进行一个快速的检查来看这个对象是否存在而不是进行一次完整的下载。如果没有东西存在，则第二个剪短，即设置场景阶段，完成了，主要构建开始进行。

If objects are found in the sstate cache, the OpenEmbedded build system works backwards from the end targets specified by the user. For example, if an image is being built, the OpenEmbedded build system first looks for the packages needed for that image and the tools needed to construct an image. If those are available, the compiler is not needed. Thus, the compiler is not even downloaded. If something was found to be unavailable, or the download or setscene task fails, the OpenEmbedded build system then tries to install dependencies, such as the compiler, from the cache.
如果在 sstate 缓存找到了对象， OpenEmbedded 构建系统从用户指定的最终目标向后工作。举个例子，如果一个镜像已经构建了， OpenEmbedded构建系统首先检查这个镜像需要的软件包和用来构建镜像的工具。如果这些可用，编译器就不是必需得了。因此甚至不用下载编译器。如果某些东西发现是不可用的，或者下载或设置场景 task 失败了， OpenEmbedded 构建系统接下来会尝试从缓存安装依赖，比如编译器。

The availability of objects in the sstate cache is handled by the function specified by the [`BB_HASHCHECK_FUNCTION`][3827] variable and returns a list of the objects that are available. The function specified by the [`BB_SETSCENE_DEPVALID`][3828] variable is the function that determines whether a given dependency needs to be followed, and whether for any given relationship the function needs to be passed. The function returns a True or False value.
sstate 缓存的对象的可用性由变量 [`BB_HASHCHECK_FUNCTION`][3827] 指定的函数控制，并且会返回一个可用对象列表。 变量 [`BB_SETSCENE_DEPVALID`][3828] 指定的函数是决定一个给定的依赖是否需要跟随，以及对给定的任意关系这个函数是否需要通过。这个函数会返回真值或假值。

### 3.6.镜像[¶][852]

The images produced by the OpenEmbedded build system are compressed forms of the root filesystem that are ready to boot on a target device. You can see from the [general Yocto Project Development Environment figure][4201] that BitBake output, in part, consists of images. This section is going to look more closely at this output:

![](https://www.yoctoproject.org/docs/current/ref-manual/figures/images.png)

For a list of example images that the Yocto Project provides, see the "[Images][4202]" chapter.

Images are written out to the [Build Directory][4203] inside the `tmp/deploy/images/ _`machine`_ /` folder as shown in the figure. This folder contains any files expected to be loaded on the target device. The [`DEPLOY_DIR`][4204] variable points to the `deploy` directory, while the [`DEPLOY_DIR_IMAGE`][4205] variable points to the appropriate directory containing images for the current configuration.

*   `_`kernel-image`_` : A kernel binary file. The [`KERNEL_IMAGETYPE`][1845] variable setting determines the naming scheme for the kernel image file. Depending on that variable, the file could begin with a variety of naming strings. The `deploy/images/ _`machine`_`  directory can contain multiple image files for the machine.

*   `_`root-filesystem-image`_` : Root filesystems for the target device (e.g. `*.ext3` or `*.bz2` files). The [`IMAGE_FSTYPES`][1846] variable setting determines the root filesystem image type. The `deploy/images/ _`machine`_`  directory can contain multiple root filesystems for the machine.

*   `_`kernel-modules`_` : Tarballs that contain all the modules built for the kernel. Kernel module tarballs exist for legacy purposes and can be suppressed by setting the [`MODULE_TARBALL_DEPLOY`][1847] variable to "0". The `deploy/images/ _`machine`_`  directory can contain multiple kernel module tarballs for the machine.

*   `_`bootloaders`_` : Bootloaders supporting the image, if applicable to the target machine. The `deploy/images/ _`machine`_`  directory can contain multiple bootloaders for the machine.

*   `_`symlinks`_` : The `deploy/images/ _`machine`_`  folder contains a symbolic link that points to the most recently built file for each machine. These links might be useful for external scripts that need to obtain the latest version of each file.

### 3.7. Application Development SDK[¶][853]

In the [general Yocto Project Development Environment figure][4206], the output labeled "Application Development SDK" represents an SDK. The SDK generation process differs depending on whether you build a standard SDK (e.g. `bitbake -c populate_sdk`  _`imagename`_ ) or an extensible SDK (e.g. `bitbake -c populate_sdk_ext`  _`imagename`_ ). This section is going to take a closer look at this output:

| 
![](https://www.yoctoproject.org/docs/current/ref-manual/figures/sdk.png)
 |

The specific form of this output is a self-extracting SDK installer (`*.sh`) that, when run, installs the SDK, which consists of a cross-development toolchain, a set of libraries and headers, and an SDK environment setup script. Running this installer essentially sets up your cross-development environment. You can think of the cross-toolchain as the "host" part because it runs on the SDK machine. You can think of the libraries and headers as the "target" part because they are built for the target hardware. The environment setup script is added so that you can initialize the environment before using the tools.

### Note

The Yocto Project supports several methods by which you can set up this cross-development environment. These methods include downloading pre-built SDK installers or building and installing your own SDK installer.

For background information on cross-development toolchains in the Yocto Project development environment, see the "[Cross-Development Toolchain Generation][3829]" section. For information on setting up a cross-development environment, see the [Yocto Project Software Development Kit (SDK) Developer's Guide][3830].

Once built, the SDK installers are written out to the `deploy/sdk` folder inside the [Build Directory][4207] as shown in the figure at the beginning of this section. Depending on the type of SDK, several variables exist that help configure these files. The following list shows the variables associated with a standard SDK:

*   [`DEPLOY_DIR`][1848]: Points to the `deploy` directory.

*   [`SDKMACHINE`][1849]: Specifies the architecture of the machine on which the cross-development tools are run to create packages for the target hardware.

*   [`SDKIMAGE_FEATURES`][1850]: Lists the features to include in the "target" part of the SDK.

*   [`TOOLCHAIN_HOST_TASK`][1851]: Lists packages that make up the host part of the SDK (i.e. the part that runs on the `SDKMACHINE`). When you use `bitbake -c populate_sdk  _`imagename`_`  to create the SDK, a set of default packages apply. This variable allows you to add more packages.

*   [`TOOLCHAIN_TARGET_TASK`][1852]: Lists packages that make up the target part of the SDK (i.e. the part built for the target hardware).

*   [`SDKPATH`][1853]: Defines the default SDK installation path offered by the installation script.

This next list, shows the variables associated with an extensible SDK:

*   [`DEPLOY_DIR`][1854]: Points to the `deploy` directory.

*   [`SDK_EXT_TYPE`][1855]: Controls whether or not shared state artifacts are copied into the extensible SDK. By default, all required shared state artifacts are copied into the SDK.

*   [`SDK_INCLUDE_PKGDATA`][1856]: Specifies whether or not packagedata will be included in the extensible SDK for all recipes in the "world" target.

*   [`SDK_INCLUDE_TOOLCHAIN`][1857]: Specifies whether or not the toolchain will be included when building the extensible SDK.

*   [`SDK_LOCAL_CONF_WHITELIST`][1858]: A list of variables allowed through from the build system configuration into the extensible SDK configuration.

*   [`SDK_LOCAL_CONF_BLACKLIST`][1859]: A list of variables not allowed through from the build system configuration into the extensible SDK configuration.

*   [`SDK_INHERIT_BLACKLIST`][1860]: A list of classes to remove from the [`INHERIT`][1861] value globally within the extensible SDK configuration.

